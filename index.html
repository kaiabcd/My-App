function startPuzzleGame() {
    document.getElementById('puz-step-3').style.display = 'flex';
    const board = document.getElementById('puz-board');
    const container = document.getElementById('puz-board-container');
    
    // === 自動偵測螢幕大小邏輯 ===
    // 1. 取得容器目前的可用寬高 (扣除 padding)
    const maxWidth = container.clientWidth - 10; 
    const maxHeight = container.clientHeight - 10;
    
    // 2. 依照圖片比例 (puzState.ratio) 計算最大能放多大
    // 如果「容器寬高比」大於「圖片寬高比」，代表容器比較寬 -> 以高度為基準
    // 如果「容器寬高比」小於「圖片寬高比」，代表容器比較窄 -> 以寬度為基準
    let boardW, boardH;
    
    if (maxWidth / maxHeight > puzState.ratio) {
      boardH = maxHeight;
      boardW = boardH * puzState.ratio;
    } else {
      boardW = maxWidth;
      boardH = boardW / puzState.ratio;
    }
    
    // 3. 設定棋盤大小
    board.style.width = boardW + "px";
    board.style.height = boardH + "px";
    board.style.gridTemplateColumns = `repeat(${puzState.size}, 1fr)`;
    // ==========================

    board.innerHTML = "";
    
    // 初始化原圖遮罩
    const overlay = document.getElementById('puz-original-overlay');
    overlay.style.backgroundImage = `url(${puzState.imgUrl})`;
    // 遮罩也要跟棋盤一樣大
    overlay.style.width = boardW + "px";
    overlay.style.height = boardH + "px";
    
    puzState.pieces = [];
    const total = puzState.size * puzState.size;
    let indices = Array.from({length: total}, (_, i) => i);
    
    // 隨機打亂
    for (let i = indices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }

    indices.forEach((imgIndex, posIndex) => {
      const piece = document.createElement('div');
      piece.className = 'puz-piece';
      piece.dataset.pos = posIndex;
      piece.dataset.img = imgIndex;
      
      piece.style.backgroundImage = `url(${puzState.imgUrl})`;
      piece.style.backgroundSize = `${puzState.size * 100}% ${puzState.size * 100}%`; 
      
      const row = Math.floor(imgIndex / puzState.size);
      const col = imgIndex % puzState.size;
      
      let xPct = (puzState.size > 1) ? (col / (puzState.size - 1)) * 100 : 0;
      let yPct = (puzState.size > 1) ? (row / (puzState.size - 1)) * 100 : 0;
      
      piece.style.backgroundPosition = `${xPct}% ${yPct}%`;
      
      piece.onclick = () => clickPiece(piece);
      board.appendChild(piece);
      puzState.pieces.push(piece);
    });

    puzState.seconds = 0;
    puzState.isPlaying = true;
    updatePuzTimer();
    puzState.timer = setInterval(() => {
      puzState.seconds++;
      updatePuzTimer();
    }, 1000);
  }
